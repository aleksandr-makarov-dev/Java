## Hibernate: Кэш, JPA, Логирование, Primary Key

### First Level Cache

Кэш **первого уровня** включён по умолчанию и действует на уровне сессии. Он управляется **PersistenceContext**, который отражает актуальное состояние базы данных. Если сущность находится в **PersistenceContext**, то повторный запрос в БД не отправляется.

![cache](./assets/cache-diagram.jpg)

Основные операции с кэшем:

1. **Session.evict(Entity)** — удаление объекта из кэша.
2. **Session.clear()** — очистка всего кэша.
3. **Session.close()** — при закрытии сессии кэш удаляется.
4. **Session.flush()** — немедленное обновление БД в соответствии с состоянием **PersistenceContext**.

Все изменения сущностей, связанных с **PersistenceContext**, будут автоматически сохранены в БД при завершении сессии, даже без явного вызова **update()**.

Каждая сессия Hibernate имеет свой собственный кэш — **PersistenceContext**.

### Жизненный цикл сущностей (Life Cycle)

![life cycle](./assets//life-cycle-diagram.png)

1. **Transient** — объект не привязан к контексту. Это состояние сущности после создания, но до сохранения.
2. **Persistent** — объект находится в **PersistenceContext** (получен из сессии или сохранён).
3. **Removed** — объект помечен на удаление.
4. **Detached** — объект больше не связан с контекстом (после вызова **evict()**, **clear()** или закрытия сессии).

Основные методы для управления жизненным циклом:

1. **Session.refresh()** — обновление объекта текущими данными из БД.
2. **Session.delete()** — удаление объекта из базы данных.
3. **Session.evict()** — удаление объекта из контекста.
4. **Session.clear()** — очистка контекста.
5. **Session.close()** — закрытие сессии.
6. **Session.merge()** — добавление объекта в контекст или применение изменений объекта к контексту.
7. **Session.update()** — обновление объекта данными из контекста.
8. **Session.isDirty()** — проверка на наличие изменений, не сохранённых в базу данных.

### Java Persistence API (JPA)

**JPA** — это спецификация Java для работы с объектно-реляционным отображением (ORM). Она предоставляет интерфейсы и аннотации для сохранения и извлечения Java объектов в/из баз данных.

**Hibernate** — одна из самых популярных реализаций JPA.

### Разница между persist() и save():

1. **save()** возвращает сгенерированный идентификатор (ID) созданной сущности, тогда как **persist()** просто сохраняет сущность без возврата ID.
2. Если сущность уже имеет идентификатор:
   - **save()** выбрасывает исключение.
   - **persist()** игнорирует сущность и не выполняет запись в базу.
3. **save()** немедленно сохраняет данные в БД, в то время как **persist()** может отложить запись до синхронизации сессии.

### Логирование (Logging)

Популярные библиотеки для логирования в Java:

1. **log4j**
2. **jdk14l**
3. **logback**
4. **simple**

**SLF4J API** — интерфейс для работы с разными логирующими библиотеками.

Уровни логирования:

1. **FATAL** — критические ошибки, требующие немедленного исправления.
2. **ERROR** — ошибки, но приложение продолжает работать.
3. **WARN** — потенциальные проблемы.
4. **INFO** — информационные сообщения.
5. **DEBUG** — подробные отладочные сообщения.
6. **TRACE** — самый детальный уровень логирования.

### Embedded Component (Встраиваемый компонент)

1. **@Embeddable** — указывает на класс как на встроенный компонент.
2. **@Embedded** — используется над полем, которое содержит встроенный компонент (аннотация необязательна).
3. \*\*

4. **@AttributeOverride(name = "PropertyName", column = @Column(name = "ColumnName"))** — используется для переопределения названий полей встроенного компонента в базе данных. Несколько таких аннотаций могут быть применены к одному полю.

### Primary Key (Первичный ключ)

1. **@Id** — указывает, что поле является первичным ключом.
2. **@GeneratedValue(strategy = GenerationType.\*)** — указывает стратегию генерации первичного ключа:

   - **AUTO** — выбор стратегии генерации автоматически в зависимости от БД.
   - **SEQUENCE** — используется последовательность для генерации идентификаторов.
   - **IDENTITY** — ответственность за генерацию ID передаётся БД.
   - **UUID** — для генерации уникальных идентификаторов на основе UUID.

3. Для настройки генерации с последовательностью можно использовать **@SequenceGenerator(name = "user_gen", sequenceName = "users_id_seq", allocationSize = 1)** в комбинации с **GenerationType.SEQUENCE** и параметром **generator = "user_gen"**. Параметр **allocationSize** определяет, на сколько будет увеличиваться значение идентификатора при каждом вызове.

4. **Составной первичный ключ**:
   - Поля, входящие в составной ключ, объединяются в класс с аннотацией **@Embeddable**.
   - Этот класс должен реализовать интерфейс **Serializable**.
   - Поле в сущности, которое используется как составной ключ, должно быть помечено аннотацией **@EmbeddedId**.

### Отношения между сущностями: @OneToOne, @ManyToOne, @ManyToMany, Lazy Initialization

- **@OneToOne** — один к одному.
- **@ManyToOne** — многие к одному.
- **@OneToMany** — один ко многим (используется в паре с **@ManyToOne**).
- **@ManyToMany** — многие ко многим (редко используется).

#### Lazy Initialization (ленивая инициализация)

По умолчанию коллекции и связанные сущности загружаются "лениво" (**LAZY**), что означает, что данные будут загружены только по запросу. Если попытаться получить доступ к лениво загружаемой сущности после завершения сессии, это приведёт к ошибке **LazyInitializationException**.

Для немедленной загрузки можно использовать параметр **fetch = FetchType.EAGER**, который загружает данные сразу же при выполнении запроса.

#### OrphalRemove (удаление дочерних элементов)

Атрибут **@OneToMany(mappedBy = "company", orphanRemoval = true)** позволяет удалять объекты из базы данных с помощью коллекции родителя.

```java
try(var sessionFactory = HibernateUtils.buildSessionFactory();
   var session = sessionFactory.openSession()){
   session.beginTransaction();

   Company company = session.get(Company.class, 3);
   company.getUsers().removeIf(user -> user.getId().equals(5));

   session.getTransaction().commit();
}
```

#### OneToOne (один к одному)
